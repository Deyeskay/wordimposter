<!doctype html>
<html lang="en">
<head>  
   <meta charset="utf-8" />
  <meta name="description" content="SK Games — Word Imposter. A fast-paced party game where one hidden imposter has no word, everyone else does—and only face-to-face deduction reveals the truth.">
  <meta property="og:title" content="SK Games — Word Imposter">
  <meta property="og:description" content="A compact hub of web games and apps by Sashi - ‘Deyeskay’ D S K.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://deyeskay.github.io/hub/">
  <meta property="og:image" content="https://deyeskay.github.io/hub/sk-icon.png">
  <meta name="twitter:card" content="summary">
  <link rel="icon" type="image/svg+xml" href="https://deyeskay.github.io/hub/favicon.svg">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0c0c0f"> 
  <title>SK Games | Word Imposter</title>
  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@500;700;800&display=swap" rel="stylesheet">
  <!-- PeerJS (CDN) -->
  <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>

<style>
 
:root{
  /* Theme palette */
  --sky1:#6AE0ED;
  --sky2:#3EBADC;
  --sky3:#0C80C8;
  --sky4:#2D7EB2;

  --card:#FDF0CE;
  --cardEdge:#E6C98A;
  --cardShadow: 0 18px 0 rgba(0,0,0,.10), 0 22px 40px rgba(0,0,0,.22);

  --ink:#2B3A55;
  --muted:#4B6485;

  --navy:#2C4F77;
  --navy2:#223F60;

  --gold1:#FEE660;
  --gold2:#F4D532;

  --teal1:#B6F1F3;
  --teal2:#45CFE0;

  --orange1:#FFCC63;
  --orange2:#F79C2E;

  --red1:#FF6A3A;
  --red2:#EE471C;

  --border:#00000022;

  --radius:24px;
  --radiusSm:16px;

  --font: "Fredoka", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
}

*{ box-sizing:border-box; }

html, body { height:100%; }

body{
  margin:0;
  font-family: var(--font);
  color: var(--ink);
  min-height:100vh;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:18px;
  overflow-x:hidden;
  overflow-y: auto;   /* IMPORTANT */
  background: radial-gradient(circle at 55% 20%, #BFF7FF 0%, var(--sky1) 25%, var(--sky2) 55%, var(--sky3) 100%);
}

/* Sunburst rays */
body::before{
  content:"";
  position:fixed;
  inset:-20%;
  background:
    radial-gradient(circle at 50% 30%, rgba(255,255,255,.35) 0 22%, rgba(255,255,255,0) 60%),
    repeating-conic-gradient(
      from 210deg at 50% 35%,
      rgba(255,255,255,.22) 0 12deg,
      rgba(255,255,255,0) 12deg 24deg
    );
  opacity:.75;
  pointer-events:none;
  transform: rotate(-6deg);
}

/* Keep app above burst */
.app{
  width:min(980px, 100%);
  position:relative;
  z-index:1;
}

/* Top bar becomes a “badge strip” */
.topbar{
  width: min(760px, 100%);
  margin-left: auto;
  margin-right: auto;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  padding:14px 16px;
  border-radius: 22px;
  border: 3px solid rgba(255,255,255,.65);
  background: linear-gradient(180deg, rgba(255,255,255,.26), rgba(255,255,255,.12));
  box-shadow: 0 12px 26px rgba(0,0,0,.18);
  margin-bottom:12px;
  backdrop-filter: blur(4px);
}

/* Brand */
.brand{ display:flex; gap:12px; align-items:flex-start; }
.logo{
  width:44px; height:44px;
  border-radius: 16px;
  background: url(https://deyeskay.github.io/hub/sk-download.svg) center/cover no-repeat;
  box-shadow:
    0 6px 0 rgba(0,0,0,.10),
    0 10px 22px rgba(0,0,0,.18);
  border: 2px solid rgba(255,255,255,.75);
}
.brand h1{
  font-size:18px;
  margin:0;
  letter-spacing:.2px;
  font-weight:800;
}
.brand p{
  margin:4px 0 0;
  color: rgba(43,58,85,.85);
  font-size:12px;
  line-height:1.35;
}

/* Status pill -> coin badge style */
.pill{
  display:inline-flex;
  gap:8px;
  align-items:center;
  padding:10px 12px;
  border-radius:999px;
  border: 3px solid rgba(255,255,255,.70);
  background: linear-gradient(180deg, rgba(255,255,255,.40), rgba(255,255,255,.18));
  font-size:12px;
  color: rgba(43,58,85,.90);
  box-shadow: 0 10px 18px rgba(0,0,0,.16);
  white-space:nowrap;
}
.dot{
  width:10px; height:10px;
  border-radius:50%;
  background: var(--red2);
  box-shadow: 0 0 0 3px rgba(255,255,255,.5), 0 0 18px rgba(238,71,28,.35);
}
.dot.ok{
  background: #2BD07D;
  box-shadow: 0 0 0 3px rgba(255,255,255,.5), 0 0 18px rgba(43,208,125,.35);
}

/* Layout grid */
.grid{
  display: grid;
  grid-template-columns: 1fr;   /* IMPORTANT: remove 2nd column */
  justify-items: center;        /* center the child card horizontally */
  gap: 14px;
}
/* Center and control width of the main card on desktop */
.grid > .card{
  width: min(760px, 100%);      /* pick a nice desktop width */
  max-height: calc(100vh - 170px);  /* adjust if needed */
  overflow: auto;                  /* IMPORTANT: internal scroll */
  -webkit-overflow-scrolling: touch;
}
@media (max-width: 860px){
  .grid{ grid-template-columns: 1fr; }
  .brand p{ display:none; } /* cleaner on small screens */
}

/* Main cards become cream panels */
.card{
  border-radius: var(--radius);
  border: 3px solid rgba(255,255,255,.80);
  background: var(--card);
  box-shadow: var(--cardShadow);
  padding:18px;
  position:relative;
}

/* Slight inner highlight like a cartoon panel */
.card::before{
  content:"";
  position:absolute;
  inset:10px;
  border-radius: calc(var(--radius) - 10px);
  border: 2px solid rgba(255,255,255,.55);
  pointer-events:none;
}

.card h2{
  margin:0 0 10px;
  font-size:16px;
  font-weight:900;
  letter-spacing:.2px;
  color: var(--ink);
}
.card p{ 
  color: rgba(43,58,85,.82);
  font-size:10px;
  line-height:1.45;
}

/* Rows */
.row{ display:flex; gap:10px; flex-wrap:wrap; }
.row > *{ flex:1; }
.row.tight > *{ flex:0 0 auto; }

/* Inputs: rounded, spacious, minimal */
input, select, button, textarea{
  width:100%;
  font-family: var(--font);
  border-radius: 18px;
  padding:12px 14px;
  outline:none;
  font-size:14px;
}

input, select, textarea{
  border: 2px solid rgba(43,58,85,.22);
  background: rgba(255,255,255,.70);
  color: var(--ink);
  box-shadow: 0 6px 0 rgba(0,0,0,.06);
}

input::placeholder, textarea::placeholder{
  color: rgba(43,58,85,.55);
}

textarea{ min-height: 120px; resize: vertical; }

/* Buttons: chunky, blocky, playful */
button{
  cursor:pointer;
  font-weight:900;
  letter-spacing:.2px;
  border: 2px solid rgba(43,58,85,.25);
  box-shadow: 0 4px 0 rgba(0,0,0,.16), 0 16px 26px rgba(0,0,0,.18);
  transform: translateY(0);
  transition: transform .08s ease, filter .15s ease, box-shadow .12s ease;
  user-select:none;
}
button:hover{ filter: brightness(1.03); }
button:active{
  transform: translateY(3px);
  box-shadow: 0 5px 0 rgba(0,0,0,.14), 0 10px 18px rgba(0,0,0,.16);
}

/* Primary / Accent button (Replay-like teal) */
.btn-accent{
  background: linear-gradient(180deg, var(--teal1), var(--teal2));
  border-color: rgba(34,63,96,.25);
  color: var(--ink);
}

/* Warning button (gold) */
.btn-warn{
  background: linear-gradient(180deg, var(--gold1), var(--gold2));
  border-color: rgba(34,63,96,.25);
  color: var(--ink);
}

/* Danger button (red) */
.btn-danger{
  background: linear-gradient(180deg, var(--red1), var(--red2));
  border-color: rgba(34,63,96,.25);
  color: #fff;
  text-shadow: 0 1px 0 rgba(0,0,0,.12);
}

/* Ghost button becomes “soft navy” secondary */
.btn-ghost{
  background: linear-gradient(180deg, rgba(44,79,119,.18), rgba(44,79,119,.10));
  border-color: rgba(44,79,119,.25);
  color: var(--ink);
}

/* Small helper text */
.small{ font-size:12px; color: rgba(43,58,85,.75); }

/* Sections */
.section{ display:none; }
.section.active{ display:block; }

.font-small, .font-small li{ font-size: 12px; color: rgba(43,58,85,.80); }

/* Divider (soft) */
.divider{
  height:2px;
  background: linear-gradient(90deg, rgba(43,58,85,.10), rgba(43,58,85,.20), rgba(43,58,85,.10));
  margin:14px 0;
  border-radius: 999px;
}

/* Player list */
.list{
  margin:10px 0 0;
  padding:0;
  list-style:none;
  border: 2px solid rgba(43,58,85,.18);
  border-radius: 18px;
  overflow:hidden;
  background: rgba(255,255,255,.55);
  box-shadow: 0 6px 0 rgba(0,0,0,.06);
}
.list li{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  padding:12px 12px;
  background: rgba(255,255,255,.40);
  border-top: 2px solid rgba(43,58,85,.10);
}
.list li:first-child{ border-top:none; }

/* Tags (HOST / YOU / ONLINE / OFFLINE) */
.tag{
  font-size:11px;
  padding:6px 10px;
  border-radius:999px;
  border: 2px solid rgba(43,58,85,.16);
  color: rgba(43,58,85,.82);
  background: rgba(255,255,255,.55);
  font-weight:800;
}
.tag.host{
  border-color: rgba(34,63,96,.20);
  background: linear-gradient(180deg, rgba(124,255,209,.30), rgba(110,231,255,.22));
}
.tag.me{
  border-color: rgba(34,63,96,.20);
  background: linear-gradient(180deg, rgba(255,230,96,.35), rgba(244,213,50,.20));
}
.tag.off{
  border-color: rgba(238,71,28,.25);
  background: linear-gradient(180deg, rgba(255,106,58,.28), rgba(238,71,28,.18));
}

/* Full-screen reveal overlay: keep burst vibe but focus on cream popup */
.revealOverlay{
  position:fixed;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  padding:22px;
  z-index:9999;
  background:
    radial-gradient(circle at 50% 20%, rgba(255,255,255,.35) 0 24%, rgba(255,255,255,0) 60%),
    repeating-conic-gradient(from 210deg at 50% 30%, rgba(255,255,255,.18) 0 12deg, rgba(255,255,255,0) 12deg 24deg),
    rgba(12,128,200,.65);
  backdrop-filter: blur(3px);
}
.revealOverlay.show{ display:flex; }

.revealCard{
  width:min(720px, 100%);
  border-radius: 30px;
  border: 4px solid rgba(255,255,255,.85);
  background: var(--card);
  box-shadow: 0 18px 0 rgba(0,0,0,.10), 0 28px 60px rgba(0,0,0,.28);
  padding:20px;
  text-align:center;
  position:relative;
}
.revealCard::before{
  content:"";
  position:absolute;
  inset:10px;
  border-radius: 22px;
  border: 2px solid rgba(255,255,255,.55);
  pointer-events:none;
}

.revealTitle{
  font-size:13px;
  color: rgba(43,58,85,.75);
  margin:0 0 10px;
  font-weight:800;
}
.revealWord{
  margin:0;
  font-size: clamp(34px, 7vw, 64px);
  letter-spacing:.6px;
  font-weight: 900;
  color: var(--ink);
  text-shadow: 0 2px 0 rgba(255,255,255,.35);
  word-break:break-word;
}
.revealRole{
  margin:10px 0 0;
  font-size:13px;
  color: rgba(43,58,85,.78);
  font-weight:800;
}
.hint{
  margin:12px 0 0;
  font-size:12px;
  color: rgba(43,58,85,.70);
}

/* Toast -> small pill */
.toast{
  position: fixed;
  left: 50%;
  bottom: 18px;
  transform: translateX(-50%);
  background: linear-gradient(180deg, rgba(255,255,255,.88), rgba(255,255,255,.70));
  border: 3px solid rgba(255,255,255,.80);
  padding:10px 14px;
  border-radius: 999px;
  color: rgba(43,58,85,.92);
  font-size: 12px;
  font-weight:800;
  box-shadow: 0 10px 20px rgba(0,0,0,.18);
  display:none;
  z-index:99999;
}
.toast.show{ display:block; }

/* Make select arrows nicer on WebKit */
select{
  appearance:none;
  background-image:
    linear-gradient(45deg, transparent 50%, rgba(43,58,85,.8) 50%),
    linear-gradient(135deg, rgba(43,58,85,.8) 50%, transparent 50%);
  background-position:
    calc(100% - 18px) calc(50% - 2px),
    calc(100% - 12px) calc(50% - 2px);
  background-size: 6px 6px, 6px 6px;
  background-repeat:no-repeat;
  padding-right:36px;
}

/* Accessibility focus */
input:focus, select:focus, textarea:focus{
  border-color: rgba(12,128,200,.55);
  box-shadow: 0 0 0 4px rgba(106,224,237,.35), 0 6px 0 rgba(0,0,0,.06);
}
button:focus{
  outline:none;
  box-shadow: 0 0 0 4px rgba(106,224,237,.35), 0 8px 0 rgba(0,0,0,.16), 0 16px 26px rgba(0,0,0,.18);
}



/* Floating help button — top-right of screen */
.helpBtn{
  position: fixed;
    top: -50px;
    right: 12px;
    z-index: 1000;
    width: 146px;
    height: 36px;
    border-radius: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    font-size: 14px;
    font-weight: 900;
    line-height: 1;
    color: #2b3a55;
    background: linear-gradient(180deg, rgba(255, 255, 255, .55), rgba(255, 255, 255, .30));
    border: 2px solid rgba(255, 255, 255, .75);
    box-shadow: 0 6px 0 rgba(0, 0, 0, .10), 0 12px 24px rgba(0, 0, 0, .18);
    cursor: pointer;
    padding: 0;
}

/* Hover */
.helpBtn:hover{
  background: linear-gradient(
    180deg,
    rgba(124,255,209,.55),
    rgba(110,231,255,.35)
  );
}

/* Pressed */
.helpBtn:active{
  transform: translateY(2px);
  box-shadow:
    0 4px 0 rgba(0,0,0,.12),
    0 8px 16px rgba(0,0,0,.16);
}


/* Help modal tweaks */
.helpCard{
  position:relative;
  max-height:80vh;
  overflow:auto;
}

/* Modal close (X) button — perfectly centered */
.closeBtn{
  position: absolute;
  top: 12px;
  right: 12px;

  width: 34px;
  height: 34px;
  border-radius: 50%;

  display: flex;
  align-items: center;
  justify-content: center;

  font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  font-size: 18px;
  font-weight: 900;
  line-height: 1;          /* IMPORTANT */

  padding: 0;              /* IMPORTANT */
  margin: 0;

  border: 2px solid rgba(0,0,0,.15);
  background: linear-gradient(
    180deg,
    rgba(255,255,255,.75),
    rgba(255,255,255,.45)
  );

  color: #2b3a55;
  cursor: pointer;

  box-shadow:
    0 4px 0 rgba(0,0,0,.12),
    0 8px 16px rgba(0,0,0,.20);
}

/* Hover */
.closeBtn:hover{
  background: linear-gradient(
    180deg,
    rgba(255,120,120,.65),
    rgba(255,90,90,.45)
  );
}

/* Press */
.closeBtn:active{
  transform: translateY(2px);
  box-shadow:
    0 2px 0 rgba(0,0,0,.14),
    0 4px 10px rgba(0,0,0,.18);
}

/* Make the Lobby action buttons stick to the top inside the scroll card */
#secLobby .row:first-of-type{
  position: sticky;
  top: 0;
  z-index: 5;

  padding: 10px 0;
  background: var(--card); /* cream background (matches your theme) */
}

/* Players list gets its own scroll area */
#secLobby #playerList{
  max-height: 250px;     /* adjust: 260-380 looks good */
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}


</style>

</head>

<body>
<div class="app">
  <div class="topbar">
    <div class="brand">
      <div class="logo"></div>
      <div>
        <h1>Word Imposter</h1>
        <p>A fast-paced party game where one hidden imposter has no word, everyone else does—and only face-to-face deduction reveals the truth. <br>(No in-app chat. Reveal + vote. Discuss offline.)</p>
      </div>
    </div>
    <div class="pill" id="statusPill">
      <span class="dot" id="statusDot"></span>
      <span id="statusText">Not connected</span>
	<button class="helpBtn" id="btnHelp" title="How to play">How to play ?</button>
    </div>
  </div>

  <div class="grid">
    <!-- LEFT: Main screens -->
    <div class="card">
      <!-- HOME -->
      <div class="section active" id="secHome">
        <h2>Join or Host</h2>
        <!-- <p>Host creates a <b>4-digit room</b> and also plays. Players join with the same code.</p> -->

        <div class="row">
          <div>
            <label class="small">Your name</label>
            <input id="inpName" placeholder="e.g., Sashi" maxlength="20" />
          </div>
        </div>
 
        <div class="row">
          <button style="margin-top: 15px;" class="btn-accent" id="btnHost">Host (Auto Create 4-digit ID)</button>
        </div>
 
        <div class="divider"></div>
		
        <div class="row">
          <div>
            <label class="small">Room ID (4 digits)</label>
            <input id="inpRoom" placeholder="e.g., 4821" inputmode="numeric" maxlength="4" />
          </div>
          <div style="flex:0.6">
            <label class="small">&nbsp;</label>
            <button id="btnJoin" class="btn-warn">Join</button>
          </div>
        </div>

        <p class="small">
          (If a room ID is already taken, host must choose a different code.)
        </p>
      </div>

      <!-- LOBBY -->
      <div class="section" id="secLobby">
        <h2>Lobby</h2>
        <p id="lobbyInfo" class="small">—</p>

        <div class="row">
          <button class="btn-accent" id="btnStartRound">Start Round</button>
          <button class="btn-ghost" id="btnLeaveRoom">Leave Room</button>
        </div>

        <div class="divider"></div>

        <h2>Players</h2>
        <ul class="list" id="playerList"></ul>

        <div class="divider"></div>

        <div id="hostControls" style="display:none;">
          <h2>Host Controls</h2>
          <p class="small">Load words JSON, generate a ChatGPT prompt to create JSON, and pick modes.</p>

          <div class="row">
            <button class="btn-ghost" id="btnCopyPrompt">Copy prompt for ChatGPT (generate JSON)</button>
            <button class="btn-warn" id="btnLoadJson">Load JSON (host)</button>
            <!-- <input type="file" id="fileJson" accept="application/json" style="display:none;"> -->
          </div>

          <div class="row">
            <div>
              <label class="small">Word mode: Imposter gets</label>
              <select id="selImposterMode">
                <option value="blank">“???” (recommended)</option>
                <option value="different" selected>Different word (same category)</option>
              </select>
            </div>
            <div>
              <label class="small">Category selection</label>
              <select id="selCategory">
                <option value="random">Random category</option>
              </select>
            </div>
          </div>

          <div class="row">
            <div>
              <label class="small">Loaded dataset summary</label>
              <textarea id="txtDataset" readonly placeholder="No JSON loaded yet."></textarea>
            </div>
          </div>
        </div>
      </div>

      <!-- ROUND -->
      <div class="section" id="secRound">
        <h2>Round</h2>
        <p class="small" id="roundInfo">—</p>

        <div class="row">
          <button class="btn-accent" id="btnRevealMine">Reveal My Word</button>
          <button class="btn-ghost" id="btnHideReveal">Hide (if open)</button>
        </div>

        <div class="divider"></div>

        <div id="hostRoundControls" style="display:none;">
          <h2>Host Controls (Round)</h2>
          <p class="small">Open voting when the in-person discussion is done.</p>
          <div class="row">
            <button class="btn-warn" id="btnOpenVoting">Open Voting</button>
            <button class="btn-ghost" id="btnBackToLobby">Back to Lobby (cancel round)</button>
          </div>
        </div>

        <div class="divider"></div>

        <h2>Players</h2>
        <ul class="list" id="playerListRound"></ul>
      </div>

      <!-- VOTE -->
      <div class="section" id="secVote">
        <h2>Vote</h2>
        <p class="small" id="voteInfo">Select who you think is the imposter. One vote per player.</p>

        <div class="row">
          <div>
            <label class="small">Vote for</label>
            <select id="selVote"></select>
          </div>
          <div style="flex:0.7">
            <label class="small">&nbsp;</label>
            <button class="btn-accent" id="btnSubmitVote">Submit Vote</button>
          </div>
        </div>

        <div class="divider"></div>

        <div id="hostVoteControls" style="display:none;">
          <h2>Host Controls (Voting)</h2>
          <p class="small">When everyone has voted, reveal results.</p>
          <div class="row">
            <button class="btn-warn" id="btnRevealResults">Reveal Results</button>
            <button class="btn-ghost" id="btnCloseVoting">Close Voting</button>
          </div>
          <p class="small" id="voteProgress">—</p>
        </div>

        <div class="divider"></div>

        <h2>Players</h2>
        <ul class="list" id="playerListVote"></ul>
      </div>

      <!-- RESULTS -->
      <div class="section" id="secResults">
        <h2>Results</h2>
        <p class="small" id="resultsSummary">—</p>

        <div class="divider"></div>
        <h2>Vote Tally</h2>
        <ul class="list" id="tallyList"></ul>

        <div class="divider"></div>

        <div class="row">
          <button class="btn-accent" id="btnNextRound">Next Round</button>
          <button class="btn-ghost" id="btnResultsToLobby">Back to Lobby</button>
        </div>
      </div>
    </div>

    <!-- RIGHT: Helpers / quick instructions -->
    <div style="display:none" class="card">
      <h2>How to Play</h2>
      <!-- <p>
        This app uses PeerJS for peer-to-peer connections. The host creates a room with ID <code>####</code>.
        Players join and connect to the host. The host is still a normal player in rounds.
      </p> -->

	 <ul class="font-small">
	 <li>One player creates a room and shares the 4-digit Room ID.</li><li>
	All players join using the Room ID and their name.</li><li>
	The host starts a round — one player is secretly chosen as the Imposter.</li>
	
	<li>Everyone taps Reveal My Word on their phone:</li>
	-Genuine players see the same secret word.<br>
	-The Imposter sees “???” (no word).<br>
	<li>Players discuss in person to figure out who the Imposter is.</li>
	
	<li>When ready, the host opens Voting.</li><li>
	Each player votes for who they think is the Imposter.</li><li>
	Results are revealed — find out who won!</li>
	 </ul>
	 
      <div class="divider"></div>

		<div style="display:none">
      <h2>JSON format (expected)</h2>
      <p class="small">Your JSON should look like this (simple & flexible):</p>
      <textarea readonly id="txtSchema"></textarea>

      <div class="divider"></div>
	  </div>

      <h2>Tips</h2>
      <ul class="small" style="margin:0; padding-left:18px; color:var(--muted); line-height:1.55;">
        <li>Use <b>Imposter = “???”</b> mode for the cleanest gameplay.</li>
        <li>Host loads JSON once; it’s used for all rounds.</li>
        <li>Discussion happens offline; open voting when ready.</li>
      </ul>
    </div>
  </div>
</div>

<!-- Full screen reveal overlay -->
<div class="revealOverlay" id="revealOverlay">
  <div class="revealCard">
    <p class="revealTitle" id="revealTitle">Your secret</p>
    <h1 class="revealWord" id="revealWord">—</h1>
    <p class="revealRole" id="revealRole">—</p>
    <p class="hint">Tap “Hide” or press Esc to quickly hide.</p>
    <div class="row tight" style="justify-content:center; margin-top:12px;">
      <button class="btn-ghost" style="width:auto; padding:10px 14px;" id="btnHideReveal2">Hide</button>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<!-- Paste JSON Modal -->
<div class="revealOverlay" id="jsonModal">
  <div class="revealCard" style="text-align:left;">
    <p class="revealTitle">Paste words JSON</p>

    <textarea id="txtJsonPaste" placeholder='Paste JSON here...'></textarea>

    <div class="row" style="margin-top:12px;">
      <button class="btn-accent" id="btnJsonLoadConfirm">Load JSON</button>
      <button class="btn-ghost" id="btnJsonCancel">Cancel</button>
    </div>

    <p class="small" style="margin-top:10px;">
      Tip: Use <b>Copy prompt for ChatGPT</b> to generate the correct JSON format.
    </p>
  </div>
</div>

<!-- How To Play Modal -->
<div class="revealOverlay" id="helpModal">
  <div class="revealCard helpCard">
    <button class="closeBtn" id="btnHelpClose">✕</button>

    <h3 style="margin-top:0">How to Play</h3>

    <ul class="font-small">
      <li>One player creates a room and shares the 4-digit Room ID.</li>
      <li>All players join using the Room ID and their name.</li>
      <li>The host starts a round — one player is secretly chosen as the Imposter.</li>
      <li>Everyone taps <b>Reveal My Word</b> on their phone:</li>
      <li>• Genuine players see the same word</li>
      <li>• The Imposter sees <b>???</b></li>
      <li>Players discuss offline to find the Imposter.</li>
      <li>The host opens voting when ready.</li>
      <li>Results are revealed — find out who won!</li>
    </ul>

    <div class="divider"></div>

    <h3>Tips</h3>
    <ul class="small" style="margin:0; padding-left:18px; line-height:1.55;">
      <li>Use <b>Imposter = “???”</b> mode for best gameplay.</li>
      <li>Host loads JSON once; reused for all rounds.</li>
      <li>Discussion happens offline.</li>
    </ul>
  </div>
</div>



<script>

// Auto-fill name from sessionStorage
const savedName = sessionStorage.getItem("wi_player_name");
if(savedName){
  const inp = document.getElementById("inpName");
  if(inp) inp.value = savedName;
}

const DEFAULT_WORDS_JSON = 
{
"title": "Ultimate Word Imposter Sets",
"categories": [
{
"name": "Fruits",
"words": [
"Apple",
"Banana",
"Orange",
"Mango",
"Pineapple",
"Strawberry",
"Blueberry",
"Grapes",
"Watermelon",
"Peach",
"Pear",
"Cherry",
"Kiwi",
"Papaya",
"Lemon",
"Lime",
"Coconut",
"Pomegranate",
"Raspberry",
"Blackberry"
]
},
{
"name": "Jobs",
"words": [
"Doctor",
"Nurse",
"Teacher",
"Professor",
"Engineer",
"Developer",
"Designer",
"Artist",
"Musician",
"Chef",
"Baker",
"Pilot",
"Flight Attendant",
"Plumber",
"Electrician",
"Carpenter",
"Mechanic",
"Accountant",
"Lawyer",
"Paralegal"
]
},
{
"name": "Animals",
"words": [
"Dog",
"Cat",
"Lion",
"Tiger",
"Elephant",
"Giraffe",
"Zebra",
"Horse",
"Cow",
"Sheep",
"Goat",
"Pig",
"Monkey",
"Gorilla",
"Kangaroo",
"Koala",
"Panda",
"Bear",
"Wolf",
"Fox"
]
},
{
"name": "Sports",
"words": [
"Soccer",
"Basketball",
"Baseball",
"Football",
"Hockey",
"Tennis",
"Badminton",
"Volleyball",
"Cricket",
"Rugby",
"Golf",
"Boxing",
"Wrestling",
"Swimming",
"Surfing",
"Skateboarding",
"Snowboarding",
"Cycling",
"Running",
"Track and Field"
]
},
{
"name": "Foods",
"words": [
"Pizza",
"Burger",
"Sandwich",
"Tacos",
"Burrito",
"Sushi",
"Ramen",
"Pasta",
"Spaghetti",
"Lasagna",
"Fried Rice",
"Noodles",
"Salad",
"Soup",
"Stew",
"Curry",
"Dumplings",
"Pancakes",
"Waffles",
"Omelet"
]
},
{
"name": "Countries",
"words": [
"United States",
"Canada",
"Mexico",
"Brazil",
"Argentina",
"United Kingdom",
"France",
"Germany",
"Italy",
"Spain",
"Portugal",
"Netherlands",
"Belgium",
"Switzerland",
"Sweden",
"Norway",
"Denmark",
"Finland",
"Poland",
"Greece"
]
},
{
"name": "Tech Gadgets",
"words": [
"Smartphone",
"Tablet",
"Laptop",
"Desktop Computer",
"Smartwatch",
"Fitness Tracker",
"Wireless Earbuds",
"Bluetooth Speaker",
"Game Console",
"VR Headset",
"Drone",
"Action Camera",
"Webcam",
"Microphone",
"Mechanical Keyboard",
"Gaming Mouse",
"Router",
"Modem",
"Power Bank",
"USB Drive"
]
},
{
"name": "Apps and Platforms",
"words": [
"YouTube",
"Netflix",
"Spotify",
"TikTok",
"Instagram",
"Snapchat",
"Discord",
"WhatsApp",
"Telegram",
"Reddit",
"Twitch",
"Zoom",
"Google Maps",
"Gmail",
"Chrome Browser",
"Apple Music",
"SoundCloud",
"Pinterest",
"Canva",
"Notion"
]
},
{
"name": "Music Genres",
"words": [
"Pop",
"Rock",
"Hip Hop",
"R&B",
"Jazz",
"Blues",
"Classical",
"Electronic",
"EDM",
"House",
"Techno",
"Trance",
"Dubstep",
"Country",
"Folk",
"Indie",
"Alternative",
"Metal",
"Punk",
"Reggae"
]
},
{
"name": "Vehicles",
"words": [
"Car",
"Sedan",
"SUV",
"Hatchback",
"Coupe",
"Convertible",
"Pickup Truck",
"Van",
"Minivan",
"Bus",
"Coach Bus",
"Motorcycle",
"Scooter",
"Bicycle",
"Electric Bike",
"Skateboard",
"Longboard",
"Train",
"Subway",
"Tram"
]
},
{
"name": "Household Items",
"words": [
"Chair",
"Table",
"Sofa",
"Couch",
"Bed",
"Mattress",
"Pillow",
"Blanket",
"Lamp",
"Light Bulb",
"Bookshelf",
"Cabinet",
"Drawer",
"Wardrobe",
"Mirror",
"Clock",
"Rug",
"Carpet",
"Curtains",
"Door Mat"
]
},
{
"name": "Superheroes",
"words": [
"Superman",
"Batman",
"Spider-Man",
"Iron Man",
"Captain America",
"Thor",
"Hulk",
"Black Widow",
"Hawkeye",
"Wonder Woman",
"Flash",
"Aquaman",
"Doctor Strange",
"Black Panther",
"Ant-Man",
"Wasp",
"Deadpool",
"Wolverine",
"Professor X",
"Vision"
]
}
]
};



/* =========================
   1) Utilities + UI helpers
   ========================= */
const $ = (id) => document.getElementById(id);

function toast(msg, ms=2200){
  const t = $("toast");
  t.textContent = msg;
  t.classList.add("show");
  setTimeout(()=>t.classList.remove("show"), ms);
}

function showSection(secId){
  const secs = ["secHome","secLobby","secRound","secVote","secResults"];
  for (const s of secs) $(s).classList.toggle("active", s === secId);
}

function setStatus(connected, text){
  $("statusDot").classList.toggle("ok", !!connected);
  $("statusText").textContent = text;
}

function clampRoomDigits(v){
  return (v || "").replace(/\D/g,"").slice(0,4);
}

function randInt(min, max){
  return Math.floor(Math.random()*(max-min+1))+min;
}

function pickRandom(arr){
  return arr[Math.floor(Math.random()*arr.length)];
}

function safeJsonParse(text){
  try { return { ok:true, data: JSON.parse(text) }; }
  catch(e){ return { ok:false, err: e?.message || "Invalid JSON" }; }
}

function openHelp(){
  $("helpModal").classList.add("show");
}

function closeHelp(){
  $("helpModal").classList.remove("show");
}

$("btnHelp").addEventListener("click", openHelp);
$("btnHelpClose").addEventListener("click", closeHelp);
/* =======================================
   2) Required JSON schema + prompt builder
   ======================================= */
const EXPECTED_SCHEMA = {
  "title": "Word Sets (any name)",
  "categories": [
    { "name": "Fruits", "words": ["Apple","Mango","Banana","Grapes"] },
    { "name": "Jobs", "words": ["Doctor","Teacher","Chef","Pilot"] }
  ]
};

$("txtSchema").value = JSON.stringify(EXPECTED_SCHEMA, null, 2);

function buildChatGPTPrompt(){
  return [
    "You are generating a JSON dataset for a browser-based 'Word Imposter' party game.",
    "",
    "Output MUST be valid JSON only (no markdown, no explanation).",
    "",
    "Required JSON schema:",
    JSON.stringify(EXPECTED_SCHEMA, null, 2),
    "",
    "Rules:",
    "1) Create 12 to 20 categories.",
    "2) Each category must have 18 to 35 unique words.",
    "3) Words should be common, easy-to-understand, single or short phrases (max 2-3 words).",
    "4) Avoid offensive/NSFW content.",
    "5) Ensure no duplicate words inside a category.",
    "",
    "Optional style:",
    "- Mix easy + medium difficulty categories.",
    "- Include modern Gen-Z friendly categories (tech, apps, pop culture) but keep words safe.",
    "",
    "Return ONLY the JSON."
  ].join("\n");
}

/* ===========================
   3) Global app state (client)
   =========================== */
const state = {
  isHost: false,
  myName: "",
  myPeerId: "",
  roomCode: "",
  roomPeerId: "",

  peer: null,           // PeerJS Peer instance
  hostConn: null,       // for joiners: DataConnection to host
  conns: new Map(),     // for host: peerId -> DataConnection

  // players array is authoritative on host, mirrored on joiners
  players: [],          // {id, name, isHost, connected, hasVoted, voteFor}
  phase: "home",        // home | lobby | round | vote | results
  round: null,          // host-authoritative round data (mirrored)
  mySecret: null,       // {role, word, categoryName}
  dataset: null,        // host dataset
  datasetSummary: "No JSON loaded yet."
};

function saveDatasetToLocal(){
  try{
    localStorage.setItem("wi_dataset", JSON.stringify(state.dataset));
  }catch(e){}
}

function loadDatasetFromLocal(){
  try{
    const saved = localStorage.getItem("wi_dataset");

    if(saved){
      const parsed = JSON.parse(saved);
      if(validateDataset(parsed).ok){
        state.dataset = parsed;
        updateDatasetUI();
        return;
      }
    }

    // Fallback → load default sample JSON
    state.dataset = DEFAULT_WORDS_JSON;
    updateDatasetUI();
  }catch(e){
    state.dataset = DEFAULT_WORDS_JSON;
    updateDatasetUI();
  }
}


/* ============================
   4) Dataset validation + UI
   ============================ */
function validateDataset(ds){
  if(!ds || typeof ds !== "object") return {ok:false, msg:"JSON must be an object."};
  if(!Array.isArray(ds.categories)) return {ok:false, msg:"Missing 'categories' array."};
  if(ds.categories.length < 1) return {ok:false, msg:"Need at least 1 category."};

  for (let i=0;i<ds.categories.length;i++){
    const c = ds.categories[i];
    if(!c || typeof c !== "object") return {ok:false, msg:`Category #${i+1} must be an object.`};
    if(typeof c.name !== "string" || !c.name.trim()) return {ok:false, msg:`Category #${i+1} missing name.`};
    if(!Array.isArray(c.words) || c.words.length < 2) return {ok:false, msg:`Category '${c.name}' needs at least 2 words.`};
    // basic word checks
    const seen = new Set();
    for (const w of c.words){
      if(typeof w !== "string" || !w.trim()) return {ok:false, msg:`Category '${c.name}' has an invalid word.`};
      const key = w.trim().toLowerCase();
      if(seen.has(key)) return {ok:false, msg:`Category '${c.name}' has duplicate word: '${w}'.`};
      seen.add(key);
    }
  }
  return {ok:true};
}

function updateDatasetUI(){
  const ds = state.dataset;
  if(!ds){
    state.datasetSummary = "No JSON loaded yet.";
    $("txtDataset").value = state.datasetSummary;
    // categories dropdown
    $("selCategory").innerHTML = `<option value="random">Random category</option>`;
    return;
  }

  const catCount = ds.categories.length;
  const wordTotal = ds.categories.reduce((a,c)=>a + (c.words?.length || 0), 0);
  state.datasetSummary =
    `Loaded: ${ds.title || "Untitled dataset"}\n` +
    `Categories: ${catCount}\n` +
    `Total words: ${wordTotal}\n\n` +
    `Example categories:\n- ` +
    ds.categories.slice(0,6).map(c => `${c.name} (${c.words.length})`).join("\n- ");

  $("txtDataset").value = state.datasetSummary;

  // build category selector
  const sel = $("selCategory");
  sel.innerHTML = `<option value="random">Random category</option>` +
                  ds.categories.map((c, idx)=> `<option value="${idx}">${c.name} (${c.words.length})</option>`).join("");
}

/* ======================
   5) Rendering player UI
   ====================== */
function renderPlayers(listElId){
  const ul = $(listElId);
  ul.innerHTML = "";

  const meId = state.myPeerId;
  for (const p of state.players){
    const li = document.createElement("li");
    const left = document.createElement("div");
    left.style.display = "flex";
    left.style.gap = "10px";
    left.style.alignItems = "center";

    const name = document.createElement("div");
    name.textContent = p.name + (p.isHost ? " (Host)" : "");
    name.style.fontWeight = "700";
    name.style.fontSize = "13px";

    const tags = document.createElement("div");
    tags.style.display = "flex";
    tags.style.gap = "6px";
    tags.style.flexWrap = "wrap";

    if (p.id === meId){
      const t = document.createElement("span");
      t.className = "tag me";
      t.textContent = "YOU";
      tags.appendChild(t);
    }
    if (p.isHost){
      const t = document.createElement("span");
      t.className = "tag host";
      t.textContent = "HOST";
      tags.appendChild(t);
    }
    if (!p.connected){
      const t = document.createElement("span");
      t.className = "tag off";
      t.textContent = "OFFLINE";
      tags.appendChild(t);
    } else {
      const t = document.createElement("span");
      t.className = "tag";
      t.textContent = "ONLINE";
      tags.appendChild(t);
    }

    left.appendChild(name);
    left.appendChild(tags);

    const right = document.createElement("div");
    right.style.display = "flex";
    right.style.gap = "8px";
    right.style.alignItems = "center";

    // vote status hints
    if (state.phase === "vote" || state.phase === "results"){
      const t = document.createElement("span");
      t.className = "tag";
      t.textContent = p.hasVoted ? "VOTED" : "NOT VOTED";
      right.appendChild(t);
    }

    li.appendChild(left);
    li.appendChild(right);
    ul.appendChild(li);
  }
}

function renderAllPlayerLists(){
  renderPlayers("playerList");
  renderPlayers("playerListRound");
  renderPlayers("playerListVote");
}

/* ===========================
   6) PeerJS: Host / Join logic
   =========================== */

/**
 * ROOM ID -> Peer ID mapping:
 * Host claims peerId = "room-####"
 * Joiners connect to that peerId.
 * This avoids needing a server for mapping.
 */
function roomIdToPeerId(code){
  return `room-${code}`;
}

function createPeer(peerId){
  // Use default public PeerJS broker.
  // NOTE: For production/reliability you may want your own PeerJS server.
  return new Peer(peerId, {
    debug: 1
  });
}

function buildMyPeerIdForJoiner(){
  // stable-ish id per browser (so refresh can rejoin with same identity)
  const key = "wi_my_peer_id";
  let id = localStorage.getItem(key);
  if(!id){
    id = `p-${Math.random().toString(36).slice(2,9)}-${Date.now().toString(36)}`;
    localStorage.setItem(key, id);
  }
  return id;
}

function ensureName(){
  const n = ($("inpName").value || "").trim();
  if(!n){
    toast("Enter your name first");
    return null;
  }
  state.myName = n.slice(0,20);
  sessionStorage.setItem("wi_player_name", state.myName);
  return state.myName;
}

async function hostRoom(){
  const name = ensureName();
  if(!name) return;

  state.isHost = true;

  // pick a 4-digit code. Try until it opens, else user can retry.
  let code = String(randInt(1000, 9999));
  // allow user to pre-fill room input to request a code
  const typed = clampRoomDigits($("inpRoom").value);
  if(typed.length === 4) code = typed;

  state.roomCode = code;
  state.roomPeerId = roomIdToPeerId(code);

  // host uses room peer id
  state.myPeerId = state.roomPeerId;
  state.peer = createPeer(state.myPeerId);

  setStatus(false, `Hosting… claiming room ${code}`);

  state.peer.on("open", (id)=>{
    setStatus(true, `Hosting room ${state.roomCode}`);
    // host is also a player
    state.players = [{
      id: state.myPeerId,
      name: state.myName,
      isHost: true,
      connected: true,
      hasVoted: false,
      voteFor: null
    }];

    // show lobby
    $("lobbyInfo").innerHTML = `Room ID: <b>${state.roomCode}</b> (share with players)`;
    $("hostControls").style.display = "";
    $("hostRoundControls").style.display = "";
    $("hostVoteControls").style.display = "";

    showSection("secLobby");
    state.phase = "lobby";

    loadDatasetFromLocal();
    updateDatasetUI();
    renderAllPlayerLists();
    updateVoteSelectOptions();
  });

  state.peer.on("connection", (conn)=>{
    // new joiner connection
    conn.on("open", ()=>{
      state.conns.set(conn.peer, conn);
      // We wait for "hello" to register name.
    });

    conn.on("data", (msg)=>{
      onHostMessage(conn, msg);
    });

    conn.on("close", ()=>{
      // mark player offline
      const p = state.players.find(x=>x.id === conn.peer);
      if(p) p.connected = false;
      state.conns.delete(conn.peer);
      broadcastRoster();
      renderAllPlayerLists();
    });

    conn.on("error", ()=>{
      const p = state.players.find(x=>x.id === conn.peer);
      if(p) p.connected = false;
      state.conns.delete(conn.peer);
      broadcastRoster();
      renderAllPlayerLists();
    });
  });

  state.peer.on("error", (err)=>{
    // If ID is taken, host must pick another code
    console.error(err);
    if(String(err?.type || "").includes("unavailable-id")){
      toast(`Room ID ${state.roomCode} is already in use. Try another 4-digit code.`);
      setStatus(false, `Room ID ${state.roomCode} taken`);
      // reset
      safeCleanupPeer();
      state.isHost = false;
      state.phase = "home";
      showSection("secHome");
      return;
    }
    toast(`Peer error: ${err?.type || "unknown"}`);
    setStatus(false, `Error: ${err?.type || "unknown"}`);
  });
}

async function joinRoom(){
  const name = ensureName();
  if(!name) return;

  const code = clampRoomDigits($("inpRoom").value);
  if(code.length !== 4){
    toast("Enter a 4-digit Room ID");
    return;
  }

  state.isHost = false;
  state.roomCode = code;
  state.roomPeerId = roomIdToPeerId(code);

  // joiner uses stable id
  state.myPeerId = buildMyPeerIdForJoiner();
  state.peer = createPeer(state.myPeerId);

  setStatus(false, `Joining room ${code}…`);

  state.peer.on("open", ()=>{
    setStatus(false, `Connecting to host…`);
    state.hostConn = state.peer.connect(state.roomPeerId, { reliable: true });

    state.hostConn.on("open", ()=>{
      setStatus(true, `Connected to room ${state.roomCode}`);
      // say hello to host
      sendToHost({ t:"hello", name: state.myName, id: state.myPeerId });
    });

    state.hostConn.on("data", (msg)=> onJoinerMessage(msg));
    state.hostConn.on("close", ()=>{
      setStatus(false, "Disconnected from host");
      toast("Disconnected");
    });
    state.hostConn.on("error", ()=>{
      setStatus(false, "Connection error");
      toast("Connection error");
    });
  });

  state.peer.on("error", (err)=>{
    console.error(err);
    toast(`Peer error: ${err?.type || "unknown"}`);
    setStatus(false, `Error: ${err?.type || "unknown"}`);
  });
}

function safeCleanupPeer(){
  try{
    if(state.hostConn){ state.hostConn.close(); state.hostConn = null; }
  }catch(e){}
  try{
    for (const c of state.conns.values()) c.close();
  }catch(e){}
  state.conns.clear();
  try{
    if(state.peer){ state.peer.destroy(); state.peer = null; }
  }catch(e){}
}

function leaveRoom(){
  safeCleanupPeer();
  state.players = [];
  state.round = null;
  state.mySecret = null;
  state.phase = "home";
  state.isHost = false;
  setStatus(false, "Not connected");
  showSection("secHome");
}

function sendToHost(msg){
  if(state.hostConn && state.hostConn.open){
    state.hostConn.send(msg);
  }
}

function hostSendTo(peerId, msg){
  const c = state.conns.get(peerId);
  if(c && c.open) c.send(msg);
}

function hostBroadcast(msg){
  for (const [peerId, c] of state.conns.entries()){
    if(c && c.open) c.send(msg);
  }
}

function broadcastRoster(){
  hostBroadcast({ t:"roster", players: state.players, phase: state.phase, round: state.round });
}

function updateVoteSelectOptions(){
  const sel = $("selVote");
  sel.innerHTML = "";
  for (const p of state.players){
    // do not allow voting self? many games allow, but usually no.
    const opt = document.createElement("option");
    opt.value = p.id;
    opt.textContent = p.name + (p.isHost ? " (Host)" : "");
    sel.appendChild(opt);
  }
}

/* =================================
   7) Host message handling (authoritative)
   ================================= */
function onHostMessage(conn, msg){
  if(!msg || typeof msg !== "object") return;

  if(msg.t === "hello"){
    const joinerId = msg.id || conn.peer;
    const joinerName = String(msg.name || "Player").slice(0,20);

    // if player already exists (reconnect), mark connected
    let p = state.players.find(x=>x.id === joinerId);
    if(!p){
      p = {
        id: joinerId,
        name: joinerName,
        isHost: false,
        connected: true,
        hasVoted: false,
        voteFor: null
      };
      state.players.push(p);
    }else{
      p.name = joinerName;
      p.connected = true;
    }

    // send current roster to all
    broadcastRoster();

    // also send roster to this joiner immediately
    hostSendTo(joinerId, { t:"roster", players: state.players, phase: state.phase, round: state.round });

    renderAllPlayerLists();
    updateVoteSelectOptions();
    return;
  }

  if(msg.t === "vote"){
    if(state.phase !== "vote") return;
    const from = conn.peer;
    const voteFor = msg.voteFor;

    const voter = state.players.find(x=>x.id === from);
    if(!voter) return;
    voter.hasVoted = true;
    voter.voteFor = voteFor;

    // send roster updates
    broadcastRoster();
    renderAllPlayerLists();
    updateHostVoteProgress();
    return;
  }

  if(msg.t === "revealRequest"){
    // optional: allow joiner to request their secret again (we do one-time by default)
    // We'll deny by default to reduce peeking. You can change this behavior.
    hostSendTo(conn.peer, { t:"toast", msg:"Reveal is one-time this round (ask host to restart round if needed)." });
    return;
  }
}

/* ===========================
   8) Joiner message handling
   =========================== */
function onJoinerMessage(msg){
  if(!msg || typeof msg !== "object") return;

  if(msg.t === "roster"){
    state.players = msg.players || [];
    state.phase = msg.phase || "lobby";
    state.round = msg.round || null;

    // UI transitions based on phase
    if(state.phase === "lobby"){
      $("lobbyInfo").innerHTML = `Room ID: <b>${state.roomCode}</b>`;
      $("hostControls").style.display = "none";
      $("hostRoundControls").style.display = "none";
      $("hostVoteControls").style.display = "none";
      showSection("secLobby");
    }else if(state.phase === "round"){
      showSection("secRound");
    }else if(state.phase === "vote"){
      showSection("secVote");
    }else if(state.phase === "results"){
      showSection("secResults");
    }

    renderAllPlayerLists();
    updateVoteSelectOptions();
    updateRoundInfoUI();
    updateVoteUI();
    updateResultsUI();
    return;
  }

  if(msg.t === "assignSecret"){
    // host sends secret for THIS player only
    state.mySecret = msg.secret;
    updateRoundInfoUI();
    return;
  }

  if(msg.t === "phase"){
    state.phase = msg.phase;
    state.round = msg.round || state.round;

    if(state.phase === "round") showSection("secRound");
    if(state.phase === "vote") showSection("secVote");
    if(state.phase === "results") showSection("secResults");

    renderAllPlayerLists();
    updateRoundInfoUI();
    updateVoteUI();
    updateResultsUI();
    return;
  }

  if(msg.t === "results"){
    state.phase = "results";
    state.round = msg.round;
    showSection("secResults");
    updateResultsUI();
    return;
  }

  if(msg.t === "toast"){
    toast(msg.msg || "—");
    return;
  }
}

/* ===========================
   9) Round creation + phases
   =========================== */
function startRoundHost(){
  if(!state.isHost) return;

  if(!state.dataset || !validateDataset(state.dataset).ok){
    toast("Host: load a valid JSON dataset first");
    return;
  }

  const onlinePlayers = state.players.filter(p=>p.connected);
  if(onlinePlayers.length < 3){
    toast("Need at least 3 connected players to start");
    return;
  }

  // reset votes
  for (const p of state.players){
    p.hasVoted = false;
    p.voteFor = null;
  }

  // choose imposter among connected players (including host)
  const imposter = pickRandom(onlinePlayers);

  // choose category
  const catSel = $("selCategory").value;
  const categories = state.dataset.categories;
  const category = (catSel === "random") ? pickRandom(categories) : categories[Number(catSel)];
  if(!category || !Array.isArray(category.words) || category.words.length < 2){
    toast("Selected category has insufficient words");
    return;
  }

  // choose word(s)
  const genuineWord = pickRandom(category.words);
  const mode = $("selImposterMode").value;

  let imposterWord = "???";
  if(mode === "different"){
    const pool = category.words.filter(w => w !== genuineWord);
    imposterWord = pool.length ? pickRandom(pool) : "???";
  }

  // create round object (authoritative)
  state.round = {
    id: "r-" + Date.now(),
    categoryName: category.name,
    genuineWord,         // host keeps it
    imposterId: imposter.id,
    imposterMode: mode,
    // (we do not broadcast genuineWord to everyone; secrets are per-player)
    votesOpen: false,
    results: null
  };

  // move to round phase
  state.phase = "round";

  // Assign secrets to each connected player (privately)
  for (const p of onlinePlayers){
    const isImposter = (p.id === state.round.imposterId);
    const secret = {
      role: isImposter ? "IMPOSTER" : "GENUINE",
      word: isImposter ? imposterWord : genuineWord,
      categoryName: category.name
    };

    if(p.id === state.myPeerId){
      state.mySecret = secret; // host's secret local
    }else{
      hostSendTo(p.id, { t:"assignSecret", secret });
    }
  }

  // Broadcast phase without leaking genuineWord
  hostBroadcast({ t:"phase", phase:"round", round: scrubRoundForClients() });

  // Host UI update
  showSection("secRound");
  updateRoundInfoUI();
  renderAllPlayerLists();
  broadcastRoster();
}

function scrubRoundForClients(){
  if(!state.round) return null;
  return {
    id: state.round.id,
    categoryName: state.round.categoryName,
    imposterId: null, // hidden
    imposterMode: state.round.imposterMode,
    votesOpen: state.round.votesOpen,
    results: state.round.results
  };
}

function openVotingHost(){
  if(!state.isHost || state.phase !== "round" || !state.round) return;
  state.phase = "vote";
  state.round.votesOpen = true;

  hostBroadcast({ t:"phase", phase:"vote", round: scrubRoundForClients() });
  broadcastRoster();

  showSection("secVote");
  updateHostVoteProgress();
  updateVoteUI();
  renderAllPlayerLists();
}

function closeVotingHost(){
  if(!state.isHost || state.phase !== "vote") return;
  // keep in vote phase but prevent further submits? simplest: just ignore new vote messages after close
  state.round.votesOpen = false;
  toast("Voting closed");
  hostBroadcast({ t:"toast", msg:"Host closed voting." });
  // still keep phase as vote (host can reveal results)
}

function submitVote(){
  if(state.isHost){
    // host submits locally
    if(state.phase !== "vote") return;
    const voteFor = $("selVote").value;

    const me = state.players.find(p => p.id === state.myPeerId);
    if(!me) return;

    if(me.hasVoted){
      toast("You already voted");
      return;
    }

    me.hasVoted = true;
    me.voteFor = voteFor;

    broadcastRoster();
    renderAllPlayerLists();
    updateHostVoteProgress();
    toast("Vote submitted ✅");
    return;
  }

  // joiner sends to host
  if(state.phase !== "vote"){
    toast("Voting is not open yet");
    return;
  }
  const voteFor = $("selVote").value;
  sendToHost({ t:"vote", voteFor });
  toast("Vote submitted ✅");
}

function computeResultsHost(){
  if(!state.isHost || state.phase !== "vote" || !state.round) return;

  // ensure all connected players voted
  const connected = state.players.filter(p => p.connected);
  const missing = connected.filter(p => !p.hasVoted);
  if(missing.length){
    toast(`Waiting for ${missing.length} player(s) to vote`);
    return;
  }

  // tally
  const tally = new Map(); // targetId -> count
  for (const p of connected){
    const v = p.voteFor;
    if(!v) continue;
    tally.set(v, (tally.get(v) || 0) + 1);
  }

  // find most voted
  let maxVotes = -1;
  let eliminatedId = null;
  for (const [id, cnt] of tally.entries()){
    if(cnt > maxVotes){
      maxVotes = cnt;
      eliminatedId = id;
    }
  }

  const imposterId = state.round.imposterId;
  const eliminatedIsImposter = (eliminatedId === imposterId);

  const win = eliminatedIsImposter ? "GENUINE TEAM WINS" : "IMPOSTER WINS";

  state.round.results = {
    win,
    eliminatedId,
    imposterId,
    categoryName: state.round.categoryName,
    genuineWord: state.round.genuineWord,
    // include per-player vote breakdown for fun (you can hide later)
    votes: connected.map(p => ({ voterId: p.id, voterName: p.name, voteFor: p.voteFor }))
  };

  state.phase = "results";

  // Broadcast results safely (this is end, so ok to reveal word)
  hostBroadcast({ t:"results", round: {
    id: state.round.id,
    categoryName: state.round.categoryName,
    imposterMode: state.round.imposterMode,
    results: state.round.results
  }});

  broadcastRoster();

  showSection("secResults");
  updateResultsUI();
}

function nextRoundHost(){
  if(!state.isHost) return;
  // Go back to lobby but keep players and dataset
  state.phase = "lobby";
  state.round = null;
  state.mySecret = null;

  // reset vote flags
  for (const p of state.players){
    p.hasVoted = false;
    p.voteFor = null;
  }

  hostBroadcast({ t:"phase", phase:"lobby", round: null });
  broadcastRoster();

  showSection("secLobby");
  renderAllPlayerLists();
}

function backToLobbyCancelHost(){
  if(!state.isHost) return;
  state.phase = "lobby";
  state.round = null;
  state.mySecret = null;

  hostBroadcast({ t:"phase", phase:"lobby", round: null });
  broadcastRoster();

  showSection("secLobby");
  renderAllPlayerLists();
}

function updateRoundInfoUI(){
  if(state.phase !== "round") return;

  const cat = state.mySecret?.categoryName || state.round?.categoryName || "—";
  $("roundInfo").textContent = `Category: ${cat}. Reveal your word on your phone. Discuss offline, then host opens voting.`;

  // host only controls already shown
}

function updateVoteUI(){
  if(state.phase !== "vote") return;
  updateVoteSelectOptions();
  if(state.isHost) updateHostVoteProgress();
}

function updateHostVoteProgress(){
  if(!state.isHost || state.phase !== "vote") return;
  const connected = state.players.filter(p => p.connected);
  const voted = connected.filter(p => p.hasVoted).length;
  $("voteProgress").textContent = `Votes: ${voted}/${connected.length} received.`;
}

function updateResultsUI(){
  if(state.phase !== "results") return;
  const r = state.round?.results;
  if(!r){
    $("resultsSummary").textContent = "—";
    return;
  }

  const imp = state.players.find(p => p.id === r.imposterId);
  const elim = state.players.find(p => p.id === r.eliminatedId);

  const impName = imp ? imp.name : "Unknown";
  const elimName = elim ? elim.name : "No one";

  $("resultsSummary").innerHTML =
    `<b>${r.win}</b><br>` +
    `Imposter: <b>${impName}</b><br>` +
    `Eliminated: <b>${elimName}</b><br>` +
    `Category: <b>${r.categoryName}</b><br>` +
    `Genuine word: <b>${r.genuineWord}</b>`;

  // tally list
  const ul = $("tallyList");
  ul.innerHTML = "";

  // rebuild tallies
  const tally = new Map();
  for (const v of r.votes){
    if(!v.voteFor) continue;
    tally.set(v.voteFor, (tally.get(v.voteFor) || 0) + 1);
  }

  // sort by count
  const entries = [...tally.entries()].sort((a,b)=>b[1]-a[1]);

  for (const [targetId, cnt] of entries){
    const target = state.players.find(p => p.id === targetId);
    const li = document.createElement("li");
    const left = document.createElement("div");
    left.style.fontWeight = "800";
    left.style.fontSize = "13px";
    left.textContent = target ? target.name : targetId;

    const right = document.createElement("div");
    right.className = "tag";
    right.textContent = `${cnt} vote(s)`;

    li.appendChild(left);
    li.appendChild(right);
    ul.appendChild(li);
  }

  if(!entries.length){
    const li = document.createElement("li");
    li.textContent = "No votes recorded.";
    ul.appendChild(li);
  }
}

/* ===========================
   10) Reveal overlay behavior
   =========================== */
let revealUsedThisRound = false;

function showReveal(){
  if(state.phase !== "round"){
    toast("Not in a round");
    return;
  }

  if(!state.mySecret){
    // joiner might not have received secret yet
    if(!state.isHost){
      sendToHost({ t:"revealRequest" });
    }
    toast("Secret not ready yet");
    return;
  }

  // One-time reveal per round for anti-peek (simple rule)
  if(revealUsedThisRound){
    toast("Reveal is one-time this round");
    return;
  }

  revealUsedThisRound = true;

  $("revealTitle").textContent = `Category: ${state.mySecret.categoryName}`;
  $("revealWord").textContent = state.mySecret.word;
  $("revealRole").innerHTML = `Role: <b>${state.mySecret.role}</b>`;

  $("revealOverlay").classList.add("show");
}

function hideReveal(){
  $("revealOverlay").classList.remove("show");
}

window.addEventListener("keydown", (e)=>{
  if(e.key === "Escape") hideReveal();
});

/* ===========================
   11) Host: Load JSON + Copy prompt
   =========================== */
$("btnCopyPrompt").addEventListener("click", async ()=>{
  const p = buildChatGPTPrompt();
  await navigator.clipboard.writeText(p);
  toast("Prompt copied ✅ Paste into ChatGPT");
});

$("btnLoadJson").addEventListener("click", ()=>{
  $("fileJson").click();
});

function openJsonModal(){
  $("txtJsonPaste").value = "";
  $("jsonModal").classList.add("show");
  $("txtJsonPaste").focus();
}

function closeJsonModal(){
  $("jsonModal").classList.remove("show");
}

$("btnLoadJson").addEventListener("click", openJsonModal);
$("btnJsonCancel").addEventListener("click", closeJsonModal);


$("btnJsonLoadConfirm").addEventListener("click", ()=>{
  const text = ($("txtJsonPaste").value || "").trim();
  if(!text){
    toast("Paste JSON first");
    return;
  }

  const parsed = safeJsonParse(text);
  if(!parsed.ok){
    toast("Invalid JSON: " + parsed.err);
    return;
  }

  const v = validateDataset(parsed.data);
  if(!v.ok){
    toast("Dataset error: " + v.msg);
    return;
  }

  state.dataset = parsed.data;
  saveDatasetToLocal();
  updateDatasetUI();
  closeJsonModal();
  toast("JSON loaded ✅");
});


/*
$("fileJson").addEventListener("change", async (e)=>{
  const f = e.target.files?.[0];
  if(!f) return;

  const text = await f.text();
  const parsed = safeJsonParse(text);
  if(!parsed.ok){
    toast("Invalid JSON: " + parsed.err);
    return;
  }

  const v = validateDataset(parsed.data);
  if(!v.ok){
    toast("Dataset error: " + v.msg);
    return;
  }

  state.dataset = parsed.data;
  saveDatasetToLocal();
  updateDatasetUI();
  toast("JSON loaded ✅");
});
*/

/* ===========================
   12) Wire UI events
   =========================== */
$("inpRoom").addEventListener("input", (e)=>{
  e.target.value = clampRoomDigits(e.target.value);
});

$("btnHost").addEventListener("click", hostRoom);
$("btnJoin").addEventListener("click", joinRoom);
$("btnLeaveRoom").addEventListener("click", leaveRoom);

$("btnStartRound").addEventListener("click", ()=>{
  if(state.isHost) startRoundHost();
  else toast("Only host can start the round");
});

$("btnRevealMine").addEventListener("click", showReveal);
$("btnHideReveal").addEventListener("click", hideReveal);
$("btnHideReveal2").addEventListener("click", hideReveal);

$("btnOpenVoting").addEventListener("click", ()=>{
  if(state.isHost) openVotingHost();
  else toast("Only host can open voting");
});

$("btnBackToLobby").addEventListener("click", ()=>{
  if(state.isHost) backToLobbyCancelHost();
  else toast("Ask host to cancel the round");
});

$("btnSubmitVote").addEventListener("click", submitVote);

$("btnRevealResults").addEventListener("click", ()=>{
  if(state.isHost) computeResultsHost();
  else toast("Only host can reveal results");
});

$("btnCloseVoting").addEventListener("click", ()=>{
  if(state.isHost) closeVotingHost();
});

$("btnNextRound").addEventListener("click", ()=>{
  if(state.isHost) nextRoundHost();
  else toast("Waiting for host to start next round");
});

$("btnResultsToLobby").addEventListener("click", ()=>{
  if(state.isHost) nextRoundHost();
  else toast("Waiting for host");
});

/* ===========================
   13) Small lifecycle helpers
   =========================== */
function resetRoundRevealFlagIfNeeded(){
  revealUsedThisRound = false;
}

function patchPhaseTransitions(){
  // whenever host changes phase, reset reveal flag
  // We'll do a quick observer via setter-ish usage in functions:
  // call resetRoundRevealFlagIfNeeded() when entering round.
}
const _startRoundHost = startRoundHost;
startRoundHost = function(){
  resetRoundRevealFlagIfNeeded();
  _startRoundHost();
};
const _onJoinerMessage = onJoinerMessage;
onJoinerMessage = function(msg){
  if(msg && msg.t === "phase" && msg.phase === "round") resetRoundRevealFlagIfNeeded();
  if(msg && msg.t === "roster" && msg.phase === "round") resetRoundRevealFlagIfNeeded();
  _onJoinerMessage(msg);
};

/* ===========================
   14) Initialize
   =========================== */
setStatus(false, "Not connected");
updateDatasetUI();
</script>
</body>
</html>

